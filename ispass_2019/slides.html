<!DOCTYPE html>
<html>
  <head>
    <title>On the Impact of Instruction Address Translation Overhead</title>
    <meta charset="utf-8">
    <style type="text/css">
      /* @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz); */
      /* @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic); */
      /* @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic); */

      /* body { font-family: 'Droid Serif'; } */
      body { font-family: 'Arial'; }
      h1, h2, h3 {
        /* font-family: 'Yanone Kaffeesatz'; */
        font-family: 'Arial';
        font-weight: normal;
      }
      .remark-slide-content {
        font-size: 22pt;
        line-height: 1.25;
      }
      .remark-slide-content h1 {
        font-size: 32pt;
      }
      .remark-slide-number {
        font-size: 18pt;
      }
      .title-institution { font-size: 18pt; }
      .title-email {
        font-size: 18pt;
        font-style: italic;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# On the Impact of Instruction Address Translation Overhead

**Yufeng Zhou**¹, Xiaowan Dong², Alan L. Cox¹, Sandhya Dwarkadas²

<div class="title-institution">¹Department of Computer Science, Rice University</div>

<div class="title-email">{yufengz, alc}@rice.edu</div>

<div class="title-institution">²Department of Computer Science, University of Rochester</div>

<div class="title-email">{xdong, sandhya}@cs.rochester.edu</div>

.bottom[![logos](./logos.svg)]

???
I'm very excited to be here today to talk about the "title".

---

# Instruction Address Translation

![Instruction address translation](./addr_trans_fast_slow_0.svg)

- Significant instruction address translation overhead.
    - PostgreSQL on a recent Intel Xeon processor: instruction address translation in progress during **14.9%** of execution cycles.
    - Intel documentation: worth investigating if &gt;**5%**.

???
So, to begin with, in a virtual memory system, when the processor needs to fetch an instruction from memory, it begins with a virtual address.

---

# Instruction Address Translation - **Superpages Present Opportunities**

![Instruction address translation](./addr_trans_fast_slow_1.svg)

???
Conceptually, the processor tries the fast path first, and if there isn't a hit.

Depending on how large of a range of addresses the translation covers

---

# Instruction Address Translation - **Missed Opportunities**

- Linux: No transparent and automatic superpages on code from a regular file system. Ugh. <font color="#ff6666">&#10008;</font>
- **FreeBSD**: transparent and automatic superpages on code from any file system. <font color="blue">&#10004;</font>
    - A conservative superpage policy: Don't bring in extra base pages merely for the purpose of creating superpages. <font color="orange">&#8263;</font>

???
The problem with current implementations and prior work is that, although you get a varying number of superpages under different policies, and each policy excels in certain scenarios, existing policies share a common problem. That is that they essentially have a single policy for both code and data, and sometimes they just sort of ignore the code side. But as we know, code and data exhibit different locality and we showed just two slides earlier that the instruction address translation overhead is significant.

In the rest of this talk, we are going to show techniques and simple heuristics that significantly reduce instruction address translation overhead.

Say here that we are doing FreeBSD because it at least supports the creation of code superpages from regular file systems.

This is emblematic of

---

# Instruction Address Translation - **Missed Opportunities**

- Example: PostgreSQL on latest FreeBSD.
    - No superpage under current policy.
    - A *simple* change in policy &rarr; ~2/3 of the main executable mapped with superpages.
        - **8.5%** reduction in execution cycles!

---

# Outline

- Introduction
- Problem #1: Conservative code superpage policy
- Problem #2: The residual code region
- Problem #3: Page table data duplication
- Takeaways

???
The way this talk is organized, we are gonna basically go over the problems and present our solutions one after another.

---

class: center, middle

# Problem #1: A superpage policy that is too conservative for code.

???
With that, we are gonna jump right into problem #1

---

# PostgreSQL Main Executable (5.953 MB) Page Access Map - First 2MB Region

![postgres ktrace](./postgres_ktrace_2m_0.svg)

---

# PostgreSQL Main Executable (5.953 MB) Page Access Map - First 2MB Region

![postgres ktrace](./postgres_ktrace_2m_1.svg)

- 16 **consecutive** 4K pages per column.

---

# PostgreSQL Main Executable (5.953 MB) - **No Superpage in First 4MB**

![postgres ktrace](./postgres_ktrace_4m.svg)

- First 2MB region: 259/512 4KB pages accessed.
- Second 2MB region: 241/512 4KB pages accessed.
- Naturally, **no superpage** under the conservative policy.

---

# PostgreSQL Main Executable (5.953 MB) - First 4MB, **I/O Clustering**

![postgres ktrace](./postgres_ktrace_4m_red_bars_01.svg)

- **I/O clustering**: The page fault handler reads from the disk at a 64KB granularity.

---

# PostgreSQL Main Executable (5.953 MB) - No Superpage in First 4MB, **but Actually Close**

![postgres ktrace](./postgres_ktrace_4m_red_bars_1.svg)

???
Important observation that the 2M regions are only a few 64KB away from being fully resident. In other words, really close to qualifying for superpages.

---

# PostgreSQL Main Executable (5.953 MB) - No Superpage in First 4MB, but Actually Close

![postgres ktrace](./postgres_ktrace_4m_red_bars_2.svg)

- **Problem #1**: A superpage policy that is too conservative for code.
- **Solution**: Bring in the non-resident 64KB clusters and create a superpage.
    - \# of resident 64KB clusters in a 2MB region &#8805; threshold &rarr; superpage.

???
Now, whenever we aggressively does something in the OS, there is a question of threshold.

---

# Relaxed Code Superpage Policy Evaluation

![Thresholds](./superpg_exec_aggressive_color.svg)
- 6 workloads, 4 thresholds (lower threshold is more aggressive)

???
We can see from this figure that for all of the applications, a threshold of 15 is sufficient. A lower threshold or in other words a more aggressive policy doesn't really make a difference beyond that point. We believe this observation is generally applicable because code exhibits locality in the sense that the compiler tries to place functions with caller-callee relationships next to each other in the binary executable, and so if a code region should generally be heavily accessed if it's accessed at all.
---

# Instruction Address Translation's Impact on Data Address Translation

![TLB](./tlb_config_min.svg)

- The second-level TLB (STLB): *shared* between code and data.
    - Similar TLB organization in earlier Intel microarchitectures (e.g. Haswell (2013)).
- **Realization**: Improved instruction address translation performance &rarr; Improved data address translation performance!

---

# Data Address Translation Performance Synergistically Improves

![Data page walk](./data_pgwalk_thld1.svg)

---

# Problem #1 and Solution Summary

![postgres ktrace](./postgres_ktrace_4m_red_bars_2.svg)

- Relaxed code superpage policy &rarr; faster execution.
- Improved instruction address translation performance &rarr; improved data address translation performance!

---

class: center, middle

# Problem #2: The residual code region.

???
And so that brings us to problem #2, which is essentially the residual code region. So how do we deal with it.

---

# PostgreSQL Main Executable - Last "Almost 2MB"

![postgres ktrace](./postgres_ktrace_last2m.svg)

???
The total size of the main executable is almost 6M, so almost three superpage-sized regions. The first two regions were shown earlier, and this is essentially the third region.

---

# Problem #2: The Residual Code Region

![postgres ktrace](./postgres_ktrace_last2m_min.svg)

- Code region rarely an integer multiple of 2MB.
- The residual code region: the &lt; 2MB leftover region.
    - &lt; 2MB &rarr; no superpage.
    - Potentially hundreds of 4KB pages.
        - Risk of spilling into the second-level TLB (STLB).
- <font color="#006633">Would be nice if we can use a superpage here.</font>

???
, potentially displacing 2MB page mappings for data

---

# Solution: Padding

- Pad out the residual code region so that it becomes a superpage.

![postgres ktrace](./postgres_ktrace_last2m_padding.svg)

???
- Ask the **linker** to extend the text section.
- Modify the **kernel** to automatically extend the executable segment and fill in the gap with no-ops.

---

class: center, middle

# Problem #3: Page table data duplication.

---

# Problem #3: Page Table Data Duplication

- Common library code referenced across different processes and applications: libc, libcrypto, libm, etc.

![PT sharing](./pt_sharing_0.svg)

---

# Solution: Page Table Page (PTP) Sharing

![PT sharing](./pt_sharing_1.svg)

---

class: center, middle

# Padding and PTP Sharing Evaluation

---

# Lower Pressure on Caches

![LLC stalls](./llc_stalls.svg)
- PTP sharing: Page table data de-duplication.
- Padding: Hundreds of leaf-level page table entries (PTEs) &rarr; a single upper-level PTE.

---

# Lower OS Memory Management Overhead

![OS counters](./os_counters_0.svg)
- Faster process creation and teardown.
    - PTP sharing: Insert/detach entire PTPs.
    - Padding: Hundreds of leaf-level PTEs &rarr; a single upper-level PTE.

---

# The Impact of Instruction Address Translation

- With all the techniques, execution cycles reduced by **18%**.
    - Without techniques, instruction address translation in progress during **~8%** of execution cycles.
- Less contention in the STLB and caches.

---

# Outline

- Introduction
- Problem #1: Conservative code superpage policy
- Problem #2: The residual code region
- Problem #3: Page table data duplication
- **Takeaways**

---

# Takeaways

- Non-trivial overhead of instruction address translation.
- Three problems and their solutions.
  - Conservative code superpage policy: relax the policy.
  - The residual code region: padding.
  - Duplicate page table data: PTP sharing.
- Improved instruction address translation performance &rarr; improved data address translation performance.

???
- Overhead exacerbated by two trends.
1. Applications are getting bigger and more complex.
- The Clang compiler: 31MB (2012) &rarr; 56MB (2018).
- A recent version of Node.js: 20 shared libraries.

2. The level of parallelism is increasing.
- Multi-core and SMT.
- Multi-process applications (e.g. PostgreSQL) and multi-process workloads (e.g. parallel compilation with Clang).

- Many modern microarchitectures share the STLB between instruction and data translations.

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        ratio: '16:9',
        countIncrementalSlides: false,
      });
    </script>
  </body>
</html>
