<!DOCTYPE html>
<html>
  <head>
    <title>On the Impact of Instruction Address Translation Overhead</title>
    <meta charset="utf-8">
    <style type="text/css">
      /* @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz); */
      /* @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic); */
      /* @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic); */

      /* body { font-family: 'Droid Serif'; } */
      body { font-family: 'Arial'; }
      h1, h2, h3 {
        /* font-family: 'Yanone Kaffeesatz'; */
        font-family: 'Arial';
        font-weight: normal;
      }
      .remark-slide-content {
        font-size: 18pt;
        line-height: 1.3;
      }
      .remark-slide-content h1 {
        font-size: 32pt;
      }
      .remark-slide-number {
        font-size: 16pt;
      }
      .title-institution { font-size: 16pt; }
      .title-email {
        font-size: 16pt;
        font-style: italic;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# On the Impact of Instruction Address Translation Overhead

**Yufeng Zhou**¹, Xiaowan Dong², Alan L. Cox¹, Sandhya Dwarkadas²

<div class="title-institution">¹Department of Computer Science, Rice University</div>

<div class="title-email">{yufengz, alc}@rice.edu</div>

<div class="title-institution">²Department of Computer Science, University of Rochester</div>

<div class="title-email">{xdong, sandhya}@cs.rochester.edu</div>

???
I'm very excited to be here today to talk about the "title".

---

# Instruction Address Translation

![Instruction address translation](./addr_trans_fast_slow_0.svg)

- Significant instruction address translation overhead.
    - PostgreSQL on a recent Intel Xeon processor: instruction address translation in progress during **14.9%** of execution cycles.
    - Intel documentation: worth investigating if &gt;**5%**.

???
So, to begin with, on a virtual memory system, when the processor needs to fetch an instruction from memory, it begins with a virtual address.

---

# Instruction Address Translation - Superpages Present Opportunities

![Instruction address translation](./addr_trans_fast_slow_1.svg)

- Translation lookaside buffer (TLB): caches virtual-to-physical translations for fast address translation.
- Base pages: finer granularity, more translation information.
- Superpages: coarser granularity, less translation information, potential memory bloat.

???
Depending on how large of a range of addresses the translation covers

---

# Instruction Address Translation - Missed Opportunities

- Operating systems support superpages.
- A single superpage (management) policy for both code and data.
- *One policy does not fit all!*
- Example: PostgreSQL on latest FreeBSD.
    - No superpage created under current policy.
    - A *simple* change in policy &rarr; ~2/3 of the main executable mapped with superpages.
        - **8.5%** reduction in execution cycles!

???
For example, FreeBSD automatically and transparently supports superpages on code from any file system.

The problem with current implementations and prior work is that, although you get a varying number of superpages under different policies, and each policy excels in certain scenarios, existing policies share a common problem. That is that they essentially have a single policy for both code and data, and sometimes they just sort of ignore the code side. But as we know, code and data exhibit different locality and we showed just two slides earlier that the instruction address translation overhead is significant.

In the rest of this talk, we are going to show techniques and simple heuristics that significantly reduce instruction address translation overhead.

---

# Outline

- Introduction
- **Problem #1: A single superpage policy that is too conservative for code**
- Solution: Relax the superpage policy for code
- Problem #2: The residual code region
- Solution: Padding
- Takeaways

???
The way this talk is organized, we are gonna basically go over the problems and present our solutions one after another.

---

class: center, middle

# Problem #1: A single superpage policy that is too conservative for code.

???
With that, we are gonna jump right into problem #1

---

# OS Support for Code Superpages

- Linux: no transparent and automatic superpages on code from a regular file system.
- FreeBSD: transparent and automatic superpages on code from any file system.
    - A conservative superpage policy: Don't bring in extra base pages merely for the purpose of creating superpages.

<!-- &#45;&#45;&#45; -->
<!--  -->
<!-- # The Impact of FreeBSD's Automatic Code Superpages -->
<!--  -->
<!-- Percentage of execution cycles servicing instruction address translation &#45; user space. -->
<!--  -->
<!-- ![FreeBSD itlb impact](./itlb_overhead_1.png) -->
<!--  -->
<!-- &#45;&#45;&#45; -->
<!--  -->
<!-- # The Impact of FreeBSD's Automatic Code Superpages -->
<!--  -->
<!-- Percentage of execution cycles servicing instruction address translation &#45; user space. -->
<!--  -->
<!-- ![FreeBSD itlb impact](./itlb_overhead_2.png) -->
<!--  -->
<!-- &#45; No superpages on PostgreSQL under FreeBSD's default policy. -->

---

# PostgreSQL Main Executable (5.953 MB) Page Access Map - First 2M Region

<img src="./postgres_ktrace_1st.png" width="798.6" height="441.1"/>

---

# PostgreSQL Main Executable (5.953 MB) Page Access Map - First 4M

<img src="./postgres_ktrace_1.png" width="1056" height="202"/>

---

# PostgreSQL Main Executable (5.953 MB) Page Access Map

<img src="./postgres_ktrace_2.png" width="1056" height="202"/>

- I/O clustering: The file system reads from the disk at a 64KB granularity.
- **Observation**: The executable is only a few 64KB away from being fully resident.
--

- **Problem #1**: A single superpage policy that is too conservative for code.
- **Solution**: Bring in the missing 64KB clusters and create a superpage.
    - Need a threshold.

???
Now, whenever we aggressively does something in the OS, there is a question of threshold.
---

# Solution #1: Relaxing the Superpage Policy

Normalized execution cycles under 4 different superpage promotion thresholds.

![Thresholds](./superpg_exec_aggressive.svg)

???
We can see from this figure that for all of the applications, a threshold of 15 is sufficient. A lower threshold or in other words a more aggressive policy doesn't really make a difference beyond that point. We believe this observation is generally applicable because code exhibits locality in the sense that the compiler tries to place functions with caller-callee relationships next to each other in the binary executable, and so if a code region should generally be heavily accessed if it's accessed at all.
---

# The Impact on Data Address Translation

TODO insert simple TLB configuration figure

- The second-level TLB (STLB): shared between code and data.
- **Realization**: Improved instruction address translation performance &rarr; reduced address translation overhead for data accesses!

![Data page walk](./superpg_pgwalk_aggressive.svg)

---

# PostgreSQL Main Executable (5.953 MB) Page Access Map - First 4M

<img src="./postgres_ktrace_2.png" width="1056" height="202"/>

- We dealt with problem #1.

---

# PostgreSQL Main Executable (5.953 MB) Page Access Map - Last "Almost 2M"

<img src="./postgres_ktrace_3.png" width="1056" height="202"/>

- Residual code region
- Mapped as 4KB base pages
- Hundreds of mappings
  - PostgreSQL accesses more than 64 of these pages.
  - The L1 instruction TLB (ITLB): 64 4KB mappings &rarr; spill into the second-level TLB (STLB).

???
, potentially displacing 2MB page mappings for data

---

class: center, middle

# Problem #2: The residual code region.

???
And so that brings us to problem #2, which is essentially the residual code region. So how do we deal with it.

---

# Solution #2: Padding

- Pad out the residual code region so that it can be mapped as a superpage.
--

- Two ways
    - Ask the *linker* to bloat the executable file.
    - Modify the *kernel* to automatically extend the executable mapping and fill in the gap following residual code.
        - Optimization: pages backing the data segment can be used as part of the padding.

???
---

# Padding Evaluation

PostgreSQL user-space results

<img src="./postgres_padding_sptp_usr.png" width="781.5" height="459"/>

---

# Padding - Lower OS Memory Management Overhead

- Reduced amount of work done in the OS.
  - Faster process creation and teardown.
    - Hundreds of leaf-level PTEs &rarr; a single upper-level PTE.

<img src="./postgres_padding_sptp_os.png" width="626.4" height="339.6"/>

---

# Padding

PostgreSQL user-space results

<img src="./postgres_padding_sptp_usr_18.png" width="781.5" height="459"/>

---

# Padding

Percentage of execution cycles servicing instruction address translation - user space.

![FreeBSD itlb impact](./itlb_overhead_3.png)

---

# Reducing Instruction Address Translation Overhead - Side Effects

- Execution cycles reduced by more than the instruction address translation overhead.
    - Data access is synergistically benefiting from less contention in the STLB and caches.

---

# Outline

- Introduction
- Problem #1: A single superpage policy that is too conservative for code
- Solution: Relax the superpage policy for code
- Problem #2: The residual code region
- Solution: Padding
- **Takeaways**

---

# Takeaways

- The overhead of instruction address translation for a variety of widely used applications is non-trivial.
  - Overhead exacerbated by two trends.
      1. Applications are getting bigger and more complex.
          <!-- &#45; The Clang compiler: 31MB (2012) &#38;rarr; 56MB (2018). -->
          <!-- &#45; A recent version of Node.js: 20 shared libraries. -->
      2. The level of parallelism is increasing.
          <!-- &#45; Multi&#45;core and SMT. -->
          <!-- &#45; Multi&#45;process applications (e.g. PostgreSQL) and multi&#45;process workloads (e.g. parallel compilation with Clang). -->
- Two problems and three solutions.
  - Single conservative superpage policy: Relax the policy for code.
  - The residual code region: padding.
- Improving address translation performance in the ITLB can reduce the address translation overhead for data accesses.
  - Many modern microarchitectures share the STLB between instruction and data translations.

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        ratio: '16:9',
        countIncrementalSlides: false,
      });
    </script>
  </body>
</html>
